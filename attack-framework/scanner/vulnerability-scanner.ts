/**
 * Vulnerability Scanner
 *
 * Automated security scanner that analyzes the IDL Protocol for known vulnerability patterns.
 */

import { Connection, PublicKey } from '@solana/web3.js';
import {
  Vulnerability,
  VulnerabilityDatabase,
  AttackVector,
  AttackSeverity,
} from '../types';

// Known vulnerability patterns based on common DeFi exploits
const VULNERABILITY_PATTERNS: VulnerabilityPattern[] = [
  // ==================== ARITHMETIC VULNERABILITIES ====================
  {
    id: 'UNCHECKED_ARITHMETIC',
    vector: AttackVector.INTEGER_OVERFLOW,
    severity: AttackSeverity.CRITICAL,
    pattern: /(?<!checked_)(?:add|sub|mul|div)\s*\(/gi,
    antiPattern: /checked_(?:add|sub|mul|div)|saturating_(?:add|sub|mul|div)/gi,
    title: 'Unchecked Arithmetic Operation',
    description: 'Arithmetic operations without overflow/underflow protection',
    impact: 'Could lead to integer overflow/underflow, manipulating token amounts',
    mitigation: 'Use checked_* or saturating_* arithmetic methods',
    references: ['https://swcregistry.io/docs/SWC-101'],
  },
  {
    id: 'UNSAFE_CAST',
    vector: AttackVector.INTEGER_OVERFLOW,
    severity: AttackSeverity.HIGH,
    pattern: /as\s+(?:u8|u16|u32|u64|u128|i8|i16|i32|i64|i128)/gi,
    antiPattern: /try_from|try_into|checked_cast/gi,
    title: 'Unsafe Type Casting',
    description: 'Type casts without bounds checking can silently truncate values',
    impact: 'Values could be truncated leading to incorrect amounts',
    mitigation: 'Use TryFrom/TryInto with proper error handling',
    references: ['https://doc.rust-lang.org/std/convert/trait.TryFrom.html'],
  },

  // ==================== ACCESS CONTROL VULNERABILITIES ====================
  {
    id: 'MISSING_SIGNER_CHECK',
    vector: AttackVector.PRIVILEGE_ESCALATION,
    severity: AttackSeverity.CRITICAL,
    pattern: /AccountInfo.*mut.*authority|admin|owner/gi,
    antiPattern: /#\[account\(.*signer.*\)\]|\.is_signer/gi,
    title: 'Missing Signer Verification',
    description: 'Authority/admin accounts not verified as transaction signers',
    impact: 'Anyone could call privileged functions',
    mitigation: 'Require is_signer check on all authority accounts',
    references: ['https://github.com/coral-xyz/anchor/blob/master/CHANGELOG.md'],
  },
  {
    id: 'MISSING_OWNER_CHECK',
    vector: AttackVector.ACCOUNT_CONFUSION,
    severity: AttackSeverity.HIGH,
    pattern: /Account.*owner|authority/gi,
    antiPattern: /require.*owner.*==|#\[account\(.*constraint.*owner.*\)\]/gi,
    title: 'Missing Owner Verification',
    description: 'Account ownership not verified before operations',
    impact: 'Operations could be performed on wrong accounts',
    mitigation: 'Always verify account.owner == expected_owner',
    references: [],
  },

  // ==================== REENTRANCY VULNERABILITIES ====================
  {
    id: 'STATE_AFTER_EXTERNAL_CALL',
    vector: AttackVector.REENTRANCY,
    severity: AttackSeverity.CRITICAL,
    pattern: /invoke(?:_signed)?.*\n(?:.*\n)*?.*state.*=/gim,
    antiPattern: /state.*=.*\n(?:.*\n)*?.*invoke/gim,
    title: 'State Update After External Call',
    description: 'State modified after CPI call (checks-effects-interactions violation)',
    impact: 'Reentrancy attack could drain funds',
    mitigation: 'Update state before external calls (CEI pattern)',
    references: ['https://solana.com/docs/programs/security#cross-program-invocations'],
  },

  // ==================== FLASH LOAN VULNERABILITIES ====================
  {
    id: 'SAME_TX_STAKE_UNSTAKE',
    vector: AttackVector.FLASH_LOAN_STAKE,
    severity: AttackSeverity.HIGH,
    pattern: /pub\s+fn\s+stake|pub\s+fn\s+unstake/gi,
    antiPattern: /last_stake_timestamp|MIN_STAKE_DURATION|stake.*too.*recent/gi,
    title: 'No Stake Duration Requirement',
    description: 'No minimum time between stake and unstake',
    impact: 'Flash loan attacks for staking bonuses',
    mitigation: 'Require minimum stake duration before unstake',
    references: [],
  },

  // ==================== ORACLE VULNERABILITIES ====================
  {
    id: 'ORACLE_NO_FRESHNESS',
    vector: AttackVector.STALE_ORACLE,
    severity: AttackSeverity.HIGH,
    pattern: /oracle.*price|get.*price|price.*feed/gi,
    antiPattern: /last_update|timestamp.*check|freshness|MAX_ORACLE_AGE/gi,
    title: 'Oracle Staleness Not Checked',
    description: 'Oracle data used without freshness verification',
    impact: 'Stale prices could be exploited for profit',
    mitigation: 'Check oracle timestamp against maximum allowed age',
    references: [],
  },
  {
    id: 'SINGLE_ORACLE_SOURCE',
    vector: AttackVector.ORACLE_MANIPULATION,
    severity: AttackSeverity.MEDIUM,
    pattern: /oracle.*=.*\w+\s*;/gi,
    antiPattern: /oracles.*\[|multiple.*oracle|oracle.*consensus/gi,
    title: 'Single Oracle Source',
    description: 'Protocol relies on single oracle source',
    impact: 'Single point of failure for price data',
    mitigation: 'Use multiple oracle sources with aggregation',
    references: [],
  },

  // ==================== MEV VULNERABILITIES ====================
  {
    id: 'NO_COMMIT_REVEAL',
    vector: AttackVector.SANDWICH_ATTACK,
    severity: AttackSeverity.MEDIUM,
    pattern: /pub\s+fn\s+(?:place_bet|swap|trade)/gi,
    antiPattern: /commit.*reveal|BET_COMMIT|hidden.*params/gi,
    title: 'Missing Commit-Reveal',
    description: 'Sensitive operations without commit-reveal scheme',
    impact: 'Vulnerable to front-running and sandwich attacks',
    mitigation: 'Implement commit-reveal for sensitive operations',
    references: [],
  },
  {
    id: 'NO_SLIPPAGE_PROTECTION',
    vector: AttackVector.SANDWICH_ATTACK,
    severity: AttackSeverity.MEDIUM,
    pattern: /swap|exchange|trade/gi,
    antiPattern: /min_out|max_slippage|slippage.*tolerance/gi,
    title: 'No Slippage Protection',
    description: 'Trades without minimum output or slippage limits',
    impact: 'Users could receive much less than expected',
    mitigation: 'Add minimum output amount parameter',
    references: [],
  },

  // ==================== ECONOMIC VULNERABILITIES ====================
  {
    id: 'NO_RATE_LIMITING',
    vector: AttackVector.DUST_ATTACK,
    severity: AttackSeverity.LOW,
    pattern: /pub\s+fn\s+(?:create|stake|bet)/gi,
    antiPattern: /MIN_.*AMOUNT|rate.*limit|cooldown|REWARD_CLAIM_COOLDOWN/gi,
    title: 'No Rate Limiting',
    description: 'No minimum amounts or cooldowns for operations',
    impact: 'Protocol could be spammed with dust transactions',
    mitigation: 'Add minimum amounts and cooldowns',
    references: [],
  },
  {
    id: 'PRECISION_LOSS_RISK',
    vector: AttackVector.PRECISION_LOSS,
    severity: AttackSeverity.LOW,
    pattern: /\/\s*\d+|division/gi,
    antiPattern: /PRECISION|DECIMALS|scale.*factor/gi,
    title: 'Potential Precision Loss',
    description: 'Division operations may lose precision',
    impact: 'Small amounts could round to zero or accumulate dust',
    mitigation: 'Use scaled arithmetic or handle remainders explicitly',
    references: [],
  },

  // ==================== GOVERNANCE VULNERABILITIES ====================
  {
    id: 'NO_TIMELOCK',
    vector: AttackVector.TIMELOCK_BYPASS,
    severity: AttackSeverity.MEDIUM,
    pattern: /set_authority|transfer_admin|upgrade/gi,
    antiPattern: /TIMELOCK|time.*lock|delay.*period|pending.*admin/gi,
    title: 'No Timelock on Admin Functions',
    description: 'Admin operations execute immediately',
    impact: 'Malicious admin could rug pull instantly',
    mitigation: 'Add timelock for sensitive admin operations',
    references: [],
  },

  // ==================== PDA VULNERABILITIES ====================
  {
    id: 'PDA_SEED_COLLISION',
    vector: AttackVector.PDA_COLLISION,
    severity: AttackSeverity.HIGH,
    pattern: /find_program_address|derive.*pda/gi,
    antiPattern: /unique.*seed|bump.*validation/gi,
    title: 'PDA Seed Collision Risk',
    description: 'PDA seeds may not be unique enough',
    impact: 'Different entities could share same PDA',
    mitigation: 'Include unique identifiers in PDA seeds',
    references: [],
  },
];

interface VulnerabilityPattern {
  id: string;
  vector: AttackVector;
  severity: AttackSeverity;
  pattern: RegExp;
  antiPattern: RegExp;
  title: string;
  description: string;
  impact: string;
  mitigation: string;
  references: string[];
}

interface ScanResult {
  file: string;
  line: number;
  column: number;
  vulnerability: VulnerabilityPattern;
  match: string;
  mitigated: boolean;
}

export class VulnerabilityScanner {
  private results: ScanResult[] = [];
  private scannedFiles: string[] = [];

  /**
   * Scan source code for vulnerabilities
   */
  async scanSource(sourceCode: string, filename: string = 'unknown'): Promise<ScanResult[]> {
    const results: ScanResult[] = [];
    this.scannedFiles.push(filename);

    const lines = sourceCode.split('\n');

    for (const pattern of VULNERABILITY_PATTERNS) {
      // Check if anti-pattern (mitigation) exists in file
      const hasMitigation = pattern.antiPattern.test(sourceCode);

      // Find all matches of the vulnerability pattern
      const matches = sourceCode.matchAll(new RegExp(pattern.pattern.source, 'gim'));

      for (const match of matches) {
        if (match.index === undefined) continue;

        // Find line number
        const beforeMatch = sourceCode.slice(0, match.index);
        const lineNumber = (beforeMatch.match(/\n/g) || []).length + 1;

        // Find column
        const lastNewline = beforeMatch.lastIndexOf('\n');
        const column = match.index - lastNewline;

        // Determine if this specific instance is mitigated
        // by checking nearby code (within 10 lines)
        const contextStart = Math.max(0, lineNumber - 5);
        const contextEnd = Math.min(lines.length, lineNumber + 5);
        const context = lines.slice(contextStart, contextEnd).join('\n');
        const contextMitigated = pattern.antiPattern.test(context);

        results.push({
          file: filename,
          line: lineNumber,
          column,
          vulnerability: pattern,
          match: match[0],
          mitigated: hasMitigation || contextMitigated,
        });
      }
    }

    this.results.push(...results);
    return results;
  }

  /**
   * Scan a directory of source files
   */
  async scanDirectory(dirPath: string): Promise<ScanResult[]> {
    const fs = await import('fs');
    const path = await import('path');

    const allResults: ScanResult[] = [];

    const scanDir = async (dir: string) => {
      const entries = await fs.promises.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
          if (!entry.name.startsWith('.') && entry.name !== 'node_modules' && entry.name !== 'target') {
            await scanDir(fullPath);
          }
        } else if (entry.name.endsWith('.rs') || entry.name.endsWith('.ts')) {
          const content = await fs.promises.readFile(fullPath, 'utf-8');
          const results = await this.scanSource(content, fullPath);
          allResults.push(...results);
        }
      }
    };

    await scanDir(dirPath);
    return allResults;
  }

  /**
   * Generate vulnerability database
   */
  generateDatabase(): VulnerabilityDatabase {
    const vulnerabilities: Vulnerability[] = [];
    const seen = new Set<string>();

    for (const result of this.results) {
      if (result.mitigated) continue;

      const key = `${result.vulnerability.id}:${result.file}:${result.line}`;
      if (seen.has(key)) continue;
      seen.add(key);

      vulnerabilities.push({
        id: `${result.vulnerability.id}-${result.file.replace(/\W/g, '-')}-L${result.line}`,
        vector: result.vulnerability.vector,
        severity: result.vulnerability.severity,
        title: result.vulnerability.title,
        description: result.vulnerability.description,
        impact: result.vulnerability.impact,
        reproduction: `Found in ${result.file} at line ${result.line}: "${result.match}"`,
        mitigation: result.vulnerability.mitigation,
        references: result.vulnerability.references,
        discoveredAt: Date.now(),
        status: 'OPEN',
      });
    }

    return {
      vulnerabilities,
      lastUpdated: Date.now(),
      totalDiscovered: vulnerabilities.length,
      totalFixed: 0,
    };
  }

  /**
   * Generate scan report
   */
  generateReport(): string {
    const lines: string[] = [];

    lines.push('# Vulnerability Scan Report\n');
    lines.push(`Scanned Files: ${this.scannedFiles.length}`);
    lines.push(`Total Findings: ${this.results.length}`);
    lines.push(`Unmitigated: ${this.results.filter(r => !r.mitigated).length}\n`);

    // Group by severity
    const bySeverity: Record<string, ScanResult[]> = {};
    for (const result of this.results.filter(r => !r.mitigated)) {
      const sev = result.vulnerability.severity;
      if (!bySeverity[sev]) bySeverity[sev] = [];
      bySeverity[sev].push(result);
    }

    const severityOrder = [
      AttackSeverity.CRITICAL,
      AttackSeverity.HIGH,
      AttackSeverity.MEDIUM,
      AttackSeverity.LOW,
      AttackSeverity.INFO,
    ];

    for (const severity of severityOrder) {
      const findings = bySeverity[severity] || [];
      if (findings.length === 0) continue;

      const icon = severity === AttackSeverity.CRITICAL ? 'ðŸ”´'
        : severity === AttackSeverity.HIGH ? 'ðŸŸ '
        : severity === AttackSeverity.MEDIUM ? 'ðŸŸ¡'
        : 'ðŸŸ¢';

      lines.push(`## ${icon} ${severity} (${findings.length})\n`);

      for (const finding of findings) {
        lines.push(`### ${finding.vulnerability.title}`);
        lines.push(`- **File:** ${finding.file}:${finding.line}`);
        lines.push(`- **Attack Vector:** ${finding.vulnerability.vector}`);
        lines.push(`- **Description:** ${finding.vulnerability.description}`);
        lines.push(`- **Impact:** ${finding.vulnerability.impact}`);
        lines.push(`- **Mitigation:** ${finding.vulnerability.mitigation}`);
        lines.push(`- **Match:** \`${finding.match.slice(0, 50)}...\``);
        lines.push('');
      }
    }

    // Mitigated findings summary
    const mitigated = this.results.filter(r => r.mitigated);
    if (mitigated.length > 0) {
      lines.push(`## âœ… Mitigated Findings (${mitigated.length})\n`);
      lines.push('The following potential vulnerabilities were detected but appear to be mitigated:\n');

      const mitigatedPatterns = new Set(mitigated.map(r => r.vulnerability.id));
      for (const patternId of mitigatedPatterns) {
        const pattern = VULNERABILITY_PATTERNS.find(p => p.id === patternId);
        if (pattern) {
          lines.push(`- **${pattern.title}**: Mitigations found in code`);
        }
      }
    }

    return lines.join('\n');
  }

  /**
   * Print colored console report
   */
  printReport(): void {
    console.log('\n\x1b[1m\x1b[35mâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\x1b[0m');
    console.log('\x1b[1m\x1b[35m  VULNERABILITY SCAN RESULTS\x1b[0m');
    console.log('\x1b[1m\x1b[35mâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\x1b[0m\n');

    console.log(`Files Scanned: ${this.scannedFiles.length}`);
    console.log(`Total Findings: ${this.results.length}`);

    const unmitigated = this.results.filter(r => !r.mitigated);
    const mitigated = this.results.filter(r => r.mitigated);

    console.log(`\x1b[31mUnmitigated: ${unmitigated.length}\x1b[0m`);
    console.log(`\x1b[32mMitigated: ${mitigated.length}\x1b[0m\n`);

    // Group unmitigated by severity
    const critical = unmitigated.filter(r => r.vulnerability.severity === AttackSeverity.CRITICAL);
    const high = unmitigated.filter(r => r.vulnerability.severity === AttackSeverity.HIGH);
    const medium = unmitigated.filter(r => r.vulnerability.severity === AttackSeverity.MEDIUM);
    const low = unmitigated.filter(r => r.vulnerability.severity === AttackSeverity.LOW);

    if (critical.length > 0) {
      console.log(`\x1b[1m\x1b[31mðŸ”´ CRITICAL: ${critical.length}\x1b[0m`);
      for (const finding of critical) {
        console.log(`   ${finding.vulnerability.title}`);
        console.log(`   \x1b[2m${finding.file}:${finding.line}\x1b[0m`);
      }
    }

    if (high.length > 0) {
      console.log(`\x1b[1m\x1b[33mðŸŸ  HIGH: ${high.length}\x1b[0m`);
      for (const finding of high) {
        console.log(`   ${finding.vulnerability.title}`);
        console.log(`   \x1b[2m${finding.file}:${finding.line}\x1b[0m`);
      }
    }

    if (medium.length > 0) {
      console.log(`\x1b[1m\x1b[33mðŸŸ¡ MEDIUM: ${medium.length}\x1b[0m`);
      for (const finding of medium.slice(0, 5)) {
        console.log(`   ${finding.vulnerability.title}`);
      }
      if (medium.length > 5) {
        console.log(`   ... and ${medium.length - 5} more`);
      }
    }

    if (low.length > 0) {
      console.log(`\x1b[2mðŸŸ¢ LOW: ${low.length}\x1b[0m`);
    }

    // Overall assessment
    console.log('\n\x1b[1mOverall Assessment:\x1b[0m');
    if (critical.length > 0) {
      console.log('\x1b[31mâš ï¸  CRITICAL vulnerabilities require immediate attention!\x1b[0m');
    } else if (high.length > 0) {
      console.log('\x1b[33mâš ï¸  HIGH severity issues should be addressed soon.\x1b[0m');
    } else if (unmitigated.length > 0) {
      console.log('\x1b[33mSome issues found but no critical vulnerabilities.\x1b[0m');
    } else {
      console.log('\x1b[32mâœ… No unmitigated vulnerabilities detected!\x1b[0m');
    }
  }
}
